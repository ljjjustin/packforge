diff -Naur openswan-2.6.32-orig/lib/libopenswan/x509dn.c openswan-2.6.32/lib/libopenswan/x509dn.c
--- openswan-2.6.32-orig/lib/libopenswan/x509dn.c	2013-05-15 11:46:35.564402264 -0400
+++ openswan-2.6.32/lib/libopenswan/x509dn.c	2013-05-15 12:02:34.032237682 -0400
@@ -719,8 +719,7 @@
 
     if (ugh != NULL) /* error, print DN as hex string */
     {
-	DBG(DBG_PARSING,
-	    DBG_log("error in DN parsing: %s", ugh));
+	openswan_log("error in DN parsing: %s", ugh);
 	str.ptr = (unsigned char *)dst;
 	str.len = dstlen;
 	hex_str(dn, &str);
@@ -1321,13 +1320,10 @@
 
 	   SECKEYPublicKey *publicKey;
 	   PRArenaPool *arena;
-	   SECStatus retVal = SECSuccess;
-	   SECItem nss_n, nss_e, dsig;
-	   SECItem signature, data;
-           mpz_t e;
-           mpz_t n;
-	   mpz_t s;
-	   chunk_t nc, ec, sc, dsigc;
+	   SECStatus retVal;
+	   SECItem nss_n, nss_e;
+	   SECItem dsig, signature;
+	   int skip;
 
 	    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 	    if (arena == NULL) {
@@ -1339,7 +1335,7 @@
 	    if (!publicKey) {
 	        PORT_FreeArena (arena, PR_FALSE);
 	        PORT_SetError (SEC_ERROR_NO_MEMORY);
-		DBG(DBG_PARSING, DBG_log("NSS: error in allocating memory to public key"));
+		DBG(DBG_X509 | DBG_CONTROL, DBG_log("NSS: error in allocating memory to public key"));
 	        return FALSE;
 	    }
 
@@ -1348,40 +1344,30 @@
 	    publicKey->pkcs11Slot = NULL;
 	    publicKey->pkcs11ID = CK_INVALID_HANDLE;
 
-            n_to_mpz(s, sig.ptr, sig.len);
-            n_to_mpz(e, issuer_cert->publicExponent.ptr,
-                        issuer_cert->publicExponent.len);
-            n_to_mpz(n, issuer_cert->modulus.ptr,
-                        issuer_cert->modulus.len);
-
-
-	    nc = mpz_to_n2((const MP_INT *)&n);
-            ec = mpz_to_n2((const MP_INT *)&e);
-	    sc = mpz_to_n2((const MP_INT *)&s);
-
-            DBG(DBG_PARSING,
-                DBG_dump_chunk("NSS cert: modulus : ", nc)
+            DBG(DBG_X509 | DBG_CONTROL, /* n */
+                DBG_dump("NSS cert: modulus : ", issuer_cert->modulus.ptr, issuer_cert->modulus.len);
             )
 
-            DBG(DBG_PARSING,
-                DBG_dump_chunk("NSS cert: exponent : ", ec)
+            DBG(DBG_X509 | DBG_CONTROL, /* e */
+                DBG_dump("NSS cert: exponent : ", issuer_cert->publicExponent.ptr, issuer_cert->publicExponent.len);
             )
 
-            DBG(DBG_PARSING,
-                DBG_dump_chunk("NSS: input signature : ", sc)
+            DBG(DBG_X509 | DBG_CONTROL, /* s */
+                DBG_dump("NSS: input signature : ", sig.ptr, sig.len);
             )
 
-            mpz_clear(e);
-            mpz_clear(n);
-            mpz_clear(s);
-
-    /*Converting n and e to nss_n and nss_e*/
-	    nss_n.data = nc.ptr;
-	    nss_n.len = (unsigned int) nc.len;
+	    /*Converting n and e to nss_n and nss_e*/
+	    skip = (issuer_cert->modulus.len > 0 && issuer_cert->modulus.ptr[0] == 0x00) ? 1 : 0;
+	    if (skip != 1) {
+		DBG(DBG_X509 | DBG_CONTROL, DBG_log("NSS: RSA Modulus has no leading 0x00 byte, modulus < 2^511"));
+	    }
+	    nss_n.data = issuer_cert->modulus.ptr + skip;
+	    nss_n.len =  issuer_cert->modulus.len - skip;
 	    nss_n.type = siBuffer;
 
-	    nss_e.data = ec.ptr;
-	    nss_e.len  = (unsigned int)ec.len;
+	    /* exponents are always < 2^255, so they never have a leading zero */
+	    nss_e.data = issuer_cert->publicExponent.ptr;
+	    nss_e.len  = issuer_cert->publicExponent.len;
 	    nss_e.type = siBuffer;
 
 	    retVal = SECITEM_CopyItem(arena, &publicKey->u.rsa.modulus, &nss_n);
@@ -1389,57 +1375,59 @@
               retVal = SECITEM_CopyItem (arena, &publicKey->u.rsa.publicExponent, &nss_e);
             }
 
-	    if(retVal != SECSuccess){
-	    pfree(nc.ptr);
-	    pfree(ec.ptr);
-	    pfree(sc.ptr);
-	    SECKEY_DestroyPublicKey (publicKey);
-            DBG_log("NSS x509dn.c: error in creating public key");
-	    return FALSE;
-	    }
+	    if(retVal != SECSuccess) {
+			SECKEY_DestroyPublicKey (publicKey);
+			loglog(RC_LOG_SERIOUS, "NSS x509dn.c: error in creating public key");
+			return FALSE;
+		}
+
+		skip = sig.len > nss_n.len && sig.ptr[0] == 0x00 ? 1 : 0;
 
+		if (skip != 1) {
+			DBG(DBG_X509 | DBG_CONTROL, DBG_log("NSS: RSA Signature has no leading 0x00 byte?"));
+		}
+	    signature.data = sig.ptr + skip;
+	    signature.len  = sig.len - skip;
 	    signature.type = siBuffer;
-	    signature.data = sc.ptr;
-	    signature.len  = (unsigned int)sc.len;
+	    DBG(DBG_X509 | DBG_CONTROL, DBG_log("RSA Signature length is %d", signature.len));
 
-	    data.type = siBuffer;
-	    data.data = digest->ptr;
-	    data.len  = (unsigned int)digest->len;
-
-	    dsigc.len = (unsigned int)sc.len;
-	    dsigc.ptr = alloc_bytes(dsigc.len, "NSS decrypted signature");
-            dsig.type = siBuffer;
-            dsig.data = dsigc.ptr;
-            dsig.len  = (unsigned int)dsigc.len;
+	    dsig.len = signature.len; /* this is a hack! yes, a digest will always be shorter then the full sig */
+	    dsig.data = alloc_bytes(dsig.len, "NSS decrypted signature");
+	    dsig.type = siBuffer;
 
     	    /*Verifying RSA signature*/
-	    if(PK11_VerifyRecover(publicKey,&signature,&dsig,osw_return_nss_password_file_info()) == SECSuccess )
+	    if(PK11_VerifyRecover(publicKey, &signature, &dsig, osw_return_nss_password_file_info()) == SECSuccess )
 	    {
-            DBG(DBG_PARSING,
-                DBG_dump("NSS decrypted sig: ", dsig.data, dsig.len);
-                DBG_log("NSS: length of decrypted sig = %d", dsig.len);
+            DBG(DBG_X509 | DBG_CONTROL,
+                DBG_dump("NSS digest sig: ", dsig.data, dsig.len);
+                DBG_log("NSS: length of digest sig = %d", dsig.len);
 	    );
+	    } else {
+			loglog(RC_LOG_SERIOUS, "NSS: PK11_VerifyRecover() failed: %d", PR_GetError());
 	    }
-
-            pfree(nc.ptr);
-            pfree(ec.ptr);
-	    pfree(sc.ptr);
 	    SECKEY_DestroyPublicKey (publicKey);
 
-	   if(memcmp(dsig.data+dsig.len-digest->len,digest->ptr, digest->len)==0)
+	   DBG(DBG_X509 | DBG_CONTROL,
+	   DBG_dump("NSS scratchpad plus computed digest sig: ", dsig.data, dsig.len);
+	   DBG_dump("NSS adjusted digest sig: ", dsig.data + dsig.len - digest->len, digest->len);
+	   DBG_dump_chunk("NSS expected digest sig: ", *digest);
+	   );
+
+	   if (memcmp(dsig.data + dsig.len - digest->len, digest->ptr, digest->len) == 0)
 	   {
-            pfree(dsigc.ptr);
-	    DBG(DBG_PARSING,
-		DBG_log("NSS: RSA Signature verified, hash values matched")
-	    );
-	    return TRUE;
+		   pfree(dsig.data);
+		   DBG(DBG_CONTROL, DBG_log("NSS: RSA Signature verified, hash values matched"));
+	 	  return TRUE;
 	   }
+	   pfree(dsig.data);
 
-           pfree(dsigc.ptr);
-	   DBG(DBG_PARSING, DBG_log("NSS: RSA Signature NOT verified"));
+	   loglog(RC_LOG_SERIOUS, "NSS: RSA Signature FAILED verification");
+	   digest->len = 0;
 	   return FALSE;
 	}
 	default:
+	    loglog(RC_LOG_SERIOUS, "decrypt_sig: RSA Signature FAILED verification - OID RSA algorithm '%d' not supported"
+	    , alg);
 	    digest->len = 0;
 	    return FALSE;
     }
@@ -1516,13 +1504,13 @@
 
     if (algorithm != OID_UNKNOWN)
     {
-	DBG(DBG_X509 | DBG_PARSING,
+	DBG(DBG_X509 | DBG_CONTROL,
 	    DBG_log("signature algorithm: '%s'",oid_names[algorithm].name);
 	)
     }
     else
     {
-	DBG(DBG_X509 | DBG_PARSING,
+	DBG(DBG_X509 | DBG_CONTROL,
 	    DBG_log("unknown signature algorithm");
 	)
     }
@@ -1533,7 +1521,7 @@
 	return FALSE;
     }
 
-    DBG(DBG_PARSING,
+    DBG(DBG_CONTROL,
 	DBG_dump_chunk("  digest:", digest)
     )
 
@@ -1582,7 +1570,7 @@
 	if (objectID == BASIC_CONSTRAINTS_CA)
 	{
 	    isCA = object.len && *object.ptr;
-	    DBG(DBG_PARSING,
+	    DBG(DBG_CONTROL,
 		DBG_log("  %s",(isCA)?"TRUE":"FALSE");
 	    )
 	}
