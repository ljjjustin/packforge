diff -Naur openswan-2.6.32-orig/include/ipsecconf/keywords.h openswan-2.6.32/include/ipsecconf/keywords.h
--- openswan-2.6.32-orig/include/ipsecconf/keywords.h	2013-04-07 21:39:11.438000115 -0400
+++ openswan-2.6.32/include/ipsecconf/keywords.h	2013-04-07 21:40:51.148000118 -0400
@@ -113,6 +113,7 @@
     KBF_SECCTX, /*security context attribute value for labeled ipsec*/
     KBF_IKE_FRAG,
     KBF_NAT_KEEPALIVE, /* per conn enabling/disabling of sending keep-alives - different from global force_keepalives */
+    KBF_INITIAL_CONTACT,
     KBF_MAX         
 };
 
diff -Naur openswan-2.6.32-orig/include/whack.h openswan-2.6.32/include/whack.h
--- openswan-2.6.32-orig/include/whack.h	2013-04-07 21:39:11.616000181 -0400
+++ openswan-2.6.32/include/whack.h	2013-04-07 21:40:51.149000114 -0400
@@ -135,6 +135,9 @@
     /* Option to allow per-conn setting of sending of NAT-T keepalives - default is enabled  */
     bool nat_keepalive;
 
+    /* Option to allow sending INITIAL-CONTACT payload - default is disabled */
+    bool initial_contact;
+
     enum keyword_sha2_truncbug sha2_truncbug;
 
     /*Checking if this connection is configured by Network Manager*/
diff -Naur openswan-2.6.32-orig/lib/libipsecconf/confread.c openswan-2.6.32/lib/libipsecconf/confread.c
--- openswan-2.6.32-orig/lib/libipsecconf/confread.c	2013-04-07 21:39:11.617000170 -0400
+++ openswan-2.6.32/lib/libipsecconf/confread.c	2013-04-07 21:40:51.149000114 -0400
@@ -75,6 +75,8 @@
 #endif
 	cfg->conn_default.options[KBF_TYPE] = KS_TUNNEL;
 
+	cfg->conn_default.options[KBF_INITIAL_CONTACT] = FALSE;
+
 	/*Cisco interop: remote peer type*/
 	cfg->conn_default.options[KBF_REMOTEPEERTYPE] = NON_CISCO;
 
diff -Naur openswan-2.6.32-orig/lib/libipsecconf/keywords.c openswan-2.6.32/lib/libipsecconf/keywords.c
--- openswan-2.6.32-orig/lib/libipsecconf/keywords.c	2013-04-07 21:39:11.665999712 -0400
+++ openswan-2.6.32/lib/libipsecconf/keywords.c	2013-04-07 21:40:51.150000112 -0400
@@ -422,7 +422,10 @@
     {"sareftrack",     kv_conn|kv_auto|kv_processed,kt_enum,KBF_SAREFTRACK,&kw_sareftrack_list},
     {"ike_frag",       kv_conn|kv_auto|kv_processed,kt_enum,KBF_IKE_FRAG,&kw_ynf_list},
     {"pfs",            kv_conn|kv_auto, kt_bool,   KBF_PFS,          NOT_ENUM},
+#ifdef NAT_TRAVERSAL
     {"nat_keepalive",  kv_conn|kv_auto, kt_bool,   KBF_NAT_KEEPALIVE,          NOT_ENUM},
+#endif
+    {"initial_contact", kv_conn|kv_auto, kt_bool,   KBF_INITIAL_CONTACT,          NOT_ENUM},
     {"sha2_truncbug",  kv_conn|kv_auto, kt_enum,   KBF_SHA2_TRUNCBUG,          &kw_sha2_truncbug},
     {"keylife",        kv_conn|kv_auto|kv_alias, kt_time,   KBF_SALIFETIME,NOT_ENUM},
     {"lifetime",       kv_conn|kv_auto|kv_alias, kt_time,   KBF_SALIFETIME,NOT_ENUM},
diff -Naur openswan-2.6.32-orig/lib/libipsecconf/starterwhack.c openswan-2.6.32/lib/libipsecconf/starterwhack.c
--- openswan-2.6.32-orig/lib/libipsecconf/starterwhack.c	2013-04-07 21:39:11.685000147 -0400
+++ openswan-2.6.32/lib/libipsecconf/starterwhack.c	2013-04-07 21:40:51.173000117 -0400
@@ -519,6 +519,10 @@
 	} else msg.nat_keepalive = TRUE;
 #endif
 
+	if(conn->options_set[KBF_INITIAL_CONTACT]) {
+		msg.initial_contact=conn->options[KBF_INITIAL_CONTACT];
+	}
+
 	/*Cisco interop : remote peer type*/
 	if(conn->options_set[KBF_REMOTEPEERTYPE]) {
 		msg.remotepeertype=conn->options[KBF_REMOTEPEERTYPE];
diff -Naur openswan-2.6.32-orig/programs/pluto/connections.c openswan-2.6.32/programs/pluto/connections.c
--- openswan-2.6.32-orig/programs/pluto/connections.c	2013-04-07 21:39:11.687000154 -0400
+++ openswan-2.6.32/programs/pluto/connections.c	2013-04-07 21:41:34.739999827 -0400
@@ -1361,6 +1361,7 @@
 
 	c->forceencaps = wm->forceencaps;
 	c->nat_keepalive = wm->nat_keepalive;
+	c->initial_contact = wm->initial_contact;
 
 	c->addr_family = wm->addr_family;
 	c->tunnel_addr_family = wm->tunnel_addr_family;
@@ -3345,7 +3346,7 @@
     
     whack_log(RC_COMMENT
 	      , "\"%s\"%s:   ike_life: %lus; ipsec_life: %lus;"
-	      " rekey_margin: %lus; rekey_fuzz: %lu%%; keyingtries: %lu%s%s "
+	      " rekey_margin: %lus; rekey_fuzz: %lu%%; keyingtries: %lu%s%s%s "
 	      , c->name
 	      , instance
 	      , (unsigned long) c->sa_ike_life_seconds
@@ -3355,6 +3356,7 @@
 	      , (unsigned long) c->sa_keying_tries
 	      , (c->sha2_truncbug) ? "; sha2_truncbug: yes" : ""
 	      , (c->nat_keepalive) ? "; nat_keepalive: yes" : ""
+	      , (c->initial_contact) ? "; initial_contact: yes" : ""
 	     );
 
     if (c->policy_next)
diff -Naur openswan-2.6.32-orig/programs/pluto/connections.h openswan-2.6.32/programs/pluto/connections.h
--- openswan-2.6.32-orig/programs/pluto/connections.h	2013-04-07 21:39:11.687000154 -0400
+++ openswan-2.6.32/programs/pluto/connections.h	2013-04-07 21:40:51.211000095 -0400
@@ -203,6 +203,7 @@
     enum dpd_action dpd_action;             /* what to do when we die */
 
     bool	    nat_keepalive;      /* Suppress sending NAT-T Keep-Alives */
+    bool	    initial_contact;      /* Send INITIAL_CONTACT (RFC-2407) payload? */
 
     /*Cisco interop: remote peer type*/
     enum keyword_remotepeertype remotepeertype;
diff -Naur openswan-2.6.32-orig/programs/pluto/ikev1_main.c openswan-2.6.32/programs/pluto/ikev1_main.c
--- openswan-2.6.32-orig/programs/pluto/ikev1_main.c	2013-04-07 21:39:11.427000115 -0400
+++ openswan-2.6.32/programs/pluto/ikev1_main.c	2013-04-07 21:40:51.251000151 -0400
@@ -1598,6 +1598,7 @@
     pb_stream id_pbs;	/* ID Payload; also used for hash calculation */
     bool send_cert = FALSE;
     bool send_cr = FALSE;
+    bool initial_contact = FALSE;
     generalName_t *requested_ca = NULL;
     cert_t mycert = st->st_connection->spd.this.cert;
 
@@ -1643,6 +1644,25 @@
      */
     free_generalNames(requested_ca, TRUE);
 
+
+    /*
+     * Determine if we need to send INITIAL_CONTACT payload 
+     * 
+     * We are INITIATOR in I2, this is not a Quick Mode rekey, so if there is
+     * a phase2 that we have for which the phase1 expired, this state has no way of
+     * finding out, so this would mean adding the payload, which would destroy the
+     * remote phase2, and cause downtime until we establish the new phase2. It
+     * is better not to send this payload, which is why the per-connection
+     * keyword default for initial_contact is 'no'. But some interop with Cisco
+     * requires this.
+     *
+     * In Quick Mode, we need to do a little more work, but that's in ikev1_quick.c
+     *
+     */
+    initial_contact = st->st_connection->initial_contact;
+    openswan_log("I will %ssend an initial contact payload", initial_contact ? "" : "NOT ");
+
+
     /* done parsing; initialize crypto  */
 
 #ifdef NAT_TRAVERSAL
@@ -1736,7 +1756,7 @@
 	if (auth_payload == ISAKMP_NEXT_HASH)
 	{
 	    /* HASH_I out */
-	    if (!out_generic_raw(ISAKMP_NEXT_NONE
+	    if (!out_generic_raw(initial_contact ? ISAKMP_NEXT_N : ISAKMP_NEXT_NONE
 				 , &isakmp_hash_desc
 				 , &md->rbody
 				 , hash_val, hash_len, "HASH_I"))
@@ -1755,7 +1775,7 @@
 		return STF_FAIL + AUTHENTICATION_FAILED;
 	    }
 
-	    if (!out_generic_raw(ISAKMP_NEXT_NONE
+	    if (!out_generic_raw(initial_contact ? ISAKMP_NEXT_N : ISAKMP_NEXT_NONE
 				 , &isakmp_signature_desc
 				 , &md->rbody
 				 , sig_val
@@ -1765,6 +1785,31 @@
 	}
     }
 
+    /* INITIAL_CONTACT */
+    if (initial_contact)
+    {
+        pb_stream notify_pbs;
+        struct isakmp_notification isan;
+
+	openswan_log("I am sending INITIAL_CONTACT");
+
+        isan.isan_np = ISAKMP_NEXT_NONE;
+        isan.isan_doi = ISAKMP_DOI_IPSEC;
+        isan.isan_protoid = PROTO_ISAKMP;
+        isan.isan_spisize = COOKIE_SIZE * 2;  
+        isan.isan_type = IPSEC_INITIAL_CONTACT;
+        if (!out_struct(&isan, &isakmp_notification_desc, &md->rbody, &notify_pbs))
+            return STF_INTERNAL_ERROR;
+        if (!out_raw(st->st_icookie, COOKIE_SIZE, &notify_pbs, "notify icookie"))
+            return STF_INTERNAL_ERROR;  
+        if (!out_raw(st->st_rcookie, COOKIE_SIZE, &notify_pbs, "notify rcookie"))
+            return STF_INTERNAL_ERROR;  
+	/* zero length data payload */
+        close_output_pbs(&notify_pbs);
+    } else {
+	openswan_log("Not sending INITIAL_CONTACT");
+    }
+
     /* encrypt message, except for fixed part of header */
 
     /* st_new_iv was computed by generate_skeyids_iv */
diff -Naur openswan-2.6.32-orig/programs/pluto/whack.c openswan-2.6.32/programs/pluto/whack.c
--- openswan-2.6.32-orig/programs/pluto/whack.c	2013-04-07 21:39:11.688000145 -0400
+++ openswan-2.6.32/programs/pluto/whack.c	2013-04-07 21:40:51.252000144 -0400
@@ -127,6 +127,7 @@
 	    " \\\n   "
 	    " [--dontrekey]"
 	    " [--aggrmode]"
+	    " [--initialcontact]"
 	    " [--forceencaps] [--no-nat_keepalive]"
             " \\\n   "
             " [--dpddelay <seconds> --dpdtimeout <seconds>]"
@@ -484,6 +485,7 @@
     CD_DPDACTION,
     CD_FORCEENCAPS,
     CD_NO_NAT_KEEPALIVE,
+    CD_INITIAL_CONTACT,
     CD_IKE,
     CD_PFSGROUP,
     CD_REMOTEPEERTYPE,
@@ -670,6 +672,7 @@
     { "dontrekey", no_argument, NULL, CD_DONT_REKEY + OO },
     { "forceencaps", no_argument, NULL, CD_FORCEENCAPS + OO },
     { "no-nat_keepalive", no_argument, NULL, CD_NO_NAT_KEEPALIVE + OO },
+    { "initialcontact", no_argument, NULL, CD_INITIAL_CONTACT + OO },
     { "dpddelay", required_argument, NULL, CD_DPDDELAY + OO + NUMERIC_ARG },
     { "dpdtimeout", required_argument, NULL, CD_DPDTIMEOUT + OO + NUMERIC_ARG },
     { "dpdaction", required_argument, NULL, CD_DPDACTION + OO },
@@ -1504,6 +1507,10 @@
             msg.nat_keepalive = FALSE;
             continue;
 
+	case CD_INITIAL_CONTACT: /* --initialcontact */
+            msg.initial_contact = TRUE;
+            continue;
+
         case CD_DPDDELAY:
             msg.dpd_delay = opt_whole;
             continue;
