diff -urNp openswan-2.6.32-cvs-patched/programs/pluto/connections.c openswan-2.6.32-current/programs/pluto/connections.c
--- openswan-2.6.32-cvs-patched/programs/pluto/connections.c	2011-09-01 16:58:25.411675280 -0400
+++ openswan-2.6.32-current/programs/pluto/connections.c	2011-09-01 17:45:06.819362996 -0400
@@ -223,7 +223,7 @@ delete_end(struct connection *c UNUSED, 
     pfreeany(e->host_addr_name);
 }
 
-static void
+void
 delete_sr(struct connection *c, struct spd_route *sr)
 {
     delete_end(c, sr, &sr->this);
diff -urNp openswan-2.6.32-cvs-patched/programs/pluto/connections.h openswan-2.6.32-current/programs/pluto/connections.h
--- openswan-2.6.32-cvs-patched/programs/pluto/connections.h	2011-09-01 16:58:25.410675281 -0400
+++ openswan-2.6.32-current/programs/pluto/connections.h	2011-09-01 17:45:20.714347230 -0400
@@ -323,6 +323,7 @@ extern void release_connection(struct co
 extern void delete_connection(struct connection *c, bool relations);
 extern void delete_connections_by_name(const char *name, bool strict);
 extern void delete_every_connection(void);
+extern void delete_sr(struct connection *c, struct spd_route *sr);
 extern char *add_group_instance(struct connection *group, const ip_subnet *target);
 extern void remove_group_instance(const struct connection *group, const char *name);
 extern void release_dead_interfaces(void);
diff -urNp openswan-2.6.32-cvs-patched/programs/pluto/ikev1_aggr.c openswan-2.6.32-current/programs/pluto/ikev1_aggr.c
--- openswan-2.6.32-cvs-patched/programs/pluto/ikev1_aggr.c	2011-09-01 16:58:25.408675283 -0400
+++ openswan-2.6.32-current/programs/pluto/ikev1_aggr.c	2011-09-01 17:48:47.008113573 -0400
@@ -795,15 +795,19 @@ aggr_inR1_outI2_tail(struct msg_digest *
     if (!encrypt_message(&md->rbody, st))
 	return STF_INTERNAL_ERROR;	/* ??? we may be partly committed */
 
-    if(c->newest_isakmp_sa != SOS_NOBODY && st->st_connection->spd.this.xauth_client && st->st_connection->remotepeertype == CISCO) {
-    DBG(DBG_CONTROL, DBG_log("This seems to be rekey, and XAUTH is not supposed to be done again"));
+    /* It seems as per Cisco implementation, XAUTH and MODECFG 
+    * are not supposed to be performed again during rekey */
+    if(c->newest_isakmp_sa != SOS_NOBODY && 
+	st->st_connection->spd.this.xauth_client && 
+	st->st_connection->remotepeertype == CISCO) {
+    DBG(DBG_CONTROL, DBG_log("Skipping XAUTH for rekey for Cisco Peer compatibility."));
     st->hidden_variables.st_xauth_client_done = TRUE;
     st->st_oakley.xauth = 0; 
 
 	if(st->st_connection->spd.this.modecfg_client) {
-	DBG(DBG_CONTROL, DBG_log("This seems to be rekey, and MODECFG is not supposed to be done again"));
+	DBG(DBG_CONTROL, DBG_log("Skipping XAUTH for rekey for Cisco Peer compatibility."));
 	st->hidden_variables.st_modecfg_vars_set = TRUE;
-        st->hidden_variables.st_modecfg_started = TRUE;
+	st->hidden_variables.st_modecfg_started = TRUE;
 	}
     }
 
@@ -895,17 +899,21 @@ aggr_inI2_tail(struct msg_digest *md
 
     /**************** done input ****************/
 
-    if(c->newest_isakmp_sa != SOS_NOBODY && st->st_connection->spd.this.xauth_client && st->st_connection->remotepeertype == CISCO) {
-    DBG(DBG_CONTROL, DBG_log("This seems to be rekey, and XAUTH is not supposed to be done again"));
-    st->hidden_variables.st_xauth_client_done = TRUE;
-    st->st_oakley.xauth = 0; 
-
-        if(st->st_connection->spd.this.modecfg_client) {
-        DBG(DBG_CONTROL, DBG_log("This seems to be rekey, and MODECFG is not supposed to be done again"));
-        st->hidden_variables.st_modecfg_vars_set = TRUE;
-        st->hidden_variables.st_modecfg_started = TRUE; 
-        }
-   }
+    /* It seems as per Cisco implementation, XAUTH and MODECFG 
+     * are not supposed to be performed again during rekey */
+    if(c->newest_isakmp_sa != SOS_NOBODY && 
+	st->st_connection->spd.this.xauth_client && 
+	st->st_connection->remotepeertype == CISCO) {
+	   DBG(DBG_CONTROL, DBG_log("Skipping XAUTH for rekey for Cisco Peer compatibility."));
+	   st->hidden_variables.st_xauth_client_done = TRUE;
+	   st->st_oakley.xauth = 0; 
+
+	   if(st->st_connection->spd.this.modecfg_client) {
+		DBG(DBG_CONTROL, DBG_log("Skipping ModeCFG for rekey for Cisco Peer compatibility."));
+		st->hidden_variables.st_modecfg_vars_set = TRUE;
+		st->hidden_variables.st_modecfg_started = TRUE; 
+	   }
+    }
 
     c->newest_isakmp_sa = st->st_serialno;
 
diff -urNp openswan-2.6.32-cvs-patched/programs/pluto/kernel.c openswan-2.6.32-current/programs/pluto/kernel.c
--- openswan-2.6.32-cvs-patched/programs/pluto/kernel.c	2011-09-01 16:58:25.411675280 -0400
+++ openswan-2.6.32-current/programs/pluto/kernel.c	2011-09-01 17:51:42.499915098 -0400
@@ -436,6 +436,7 @@ fmt_common_shell_out(char *buf, int blen
 #endif
 		    "%s "           /* PLUTO_MY_SRCIP - if any */
 #ifdef XAUTH
+		    "PLUTO_IS_PEER_CISCO='%u' "
 		    "PLUTO_CISCO_DNS_INFO='%s' "
 		    "PLUTO_CISCO_DOMAIN_INFO='%s' "
 		    "PLUTO_PEER_BANNER='%s' "
@@ -470,6 +471,7 @@ fmt_common_shell_out(char *buf, int blen
 #endif
 		    , srcip_str
 #ifdef XAUTH
+		    , c->remotepeertype
 		    , c->cisco_dns_info ? c->cisco_dns_info : ""
 		    , c->cisco_domain_info ? c->cisco_domain_info : ""
 		    , c->cisco_banner ? c->cisco_banner : ""
@@ -485,7 +487,6 @@ fmt_common_shell_out(char *buf, int blen
 	return ((result>=blen) || (result<0))? -1 : result;
 }
 
-//static bool
 bool
 do_command(struct connection *c, struct spd_route *sr, const char *verb, struct state *st)
 {
diff -urNp openswan-2.6.32-cvs-patched/programs/pluto/xauth.c openswan-2.6.32-current/programs/pluto/xauth.c
--- openswan-2.6.32-cvs-patched/programs/pluto/xauth.c	2011-09-01 16:58:25.412675279 -0400
+++ openswan-2.6.32-current/programs/pluto/xauth.c	2011-09-01 17:55:54.678630347 -0400
@@ -1785,7 +1785,9 @@ modecfg_inR1(struct msg_digest *md)
 				 , caddr);
 		    
 		    if(addrbytesptr(&c->spd.this.host_srcip, NULL) == 0
-		       || isanyaddr(&c->spd.this.host_srcip)) {
+		       || isanyaddr(&c->spd.this.host_srcip)
+			|| c->remotepeertype == CISCO ) { 
+			/*with remotepeertype == CISCO, overwrite the previous address with the new received address*/
 			openswan_log("setting ip source address to %s"
 				     , caddr);
 			c->spd.this.host_srcip = a;
@@ -1835,7 +1837,11 @@ modecfg_inR1(struct msg_digest *md)
 			{
 			    /* concatenate new IP address string on end of
 			     * existing string, separated by ' '.
+			     * concatenate only if the received DNS is not
+			     * already present in the current string.
 			     */
+ 
+			    if( !strstr(c->cisco_dns_info, caddr) ) {
 			    size_t sz_old = strlen(old);
 			    size_t sz_added = strlen(caddr) + 1;
 			    char *new = alloc_bytes(sz_old + 1 + sz_added, "cisco_dns_info+");
@@ -1845,6 +1851,7 @@ modecfg_inR1(struct msg_digest *md)
 			    memcpy(new + sz_old + 1, caddr, sz_added);
 			    c->cisco_dns_info = new;
 			    pfree(old);
+			   }
 			}
 		    }
 
@@ -1860,18 +1867,22 @@ modecfg_inR1(struct msg_digest *md)
 		    break;
 
 		case CISCO_BANNER:
+		    /*if received again, free the previous and create the new one*/
+		    pfreeany(st->st_connection->cisco_banner);
 		    st->st_connection->cisco_banner = cisco_stringify(&strattr,"Cisco Banner");
                     resp |= LELEM(attr.isaat_af_type);
                     break;
 
 		case CISCO_DEF_DOMAIN:
+		    /*if received again, free the previous one and create the new one*/
+		    pfreeany(st->st_connection->cisco_domain_info);
 		    st->st_connection->cisco_domain_info = cisco_stringify(&strattr,"Cisco Domain");
                     resp |= LELEM(attr.isaat_af_type);
                     break;
 
 		case CISCO_SPLIT_INC:
                 {
-                    struct spd_route *tmp_spd;
+                    struct spd_route *tmp_spd, *tmp_spd1;
                     ip_address a;
                     char caddr[SUBNETTOT_BUF];
                     size_t len = pbs_left(&strattr);
@@ -1884,6 +1895,18 @@ modecfg_inR1(struct msg_digest *md)
                     tmp_spd2->that.has_client_wildcard = FALSE;
                     }
 
+					/* receiving remote subnets information again
+					* free the previous ones before proceeding. 
+					*/
+					tmp_spd = tmp_spd2->next;
+					tmp_spd2->next = NULL;
+					while(tmp_spd ) {
+					delete_sr(c, tmp_spd);
+					tmp_spd1 = tmp_spd->next;
+					pfree(tmp_spd);
+					tmp_spd = tmp_spd1;	    	
+					}
+
                     while (len > 0) {
                     u_int32_t *ap;
                     tmp_spd = clone_thing(c->spd, "remote subnets policies");
@@ -2135,7 +2158,7 @@ stf_status xauth_client_resp(struct stat
 
 		    /*
 		     * Do not store the password read from the prompt. The password
-		     * could have be read from a one-time token device (like SecureID)
+		     * could have been read from a one-time token device (like SecureID)
 		     * or the password could have been entereted wrong,
 		     */
 		    if (password_read_from_prompt) {
diff -urNp openswan-2.6.32-cvs-patched/programs/rsasigkey/rsasigkey.c openswan-2.6.32-current/programs/rsasigkey/rsasigkey.c
--- openswan-2.6.32-cvs-patched/programs/rsasigkey/rsasigkey.c	2011-09-01 16:58:25.414675275 -0400
+++ openswan-2.6.32-current/programs/rsasigkey/rsasigkey.c	2011-10-03 13:25:08.448750864 -0400
@@ -564,7 +564,7 @@ rsasigkey(int nbits, char *configdir, ch
     mpz_init(n);
     mpz_init(e);
 
-    pwdata.source = password ? PW_PLAINTEXT : PW_NONE;
+    pwdata.source = password ? (strcmp(password, "/etc/ipsec.d/nsspassword")? PW_PLAINTEXT: PW_FROMFILE) : PW_NONE;
     pwdata.data = password ? password : NULL;
 
     do {
diff -urNp openswan-2.6.32-cvs-patched/programs/_updown.netkey/_updown.netkey.in openswan-2.6.32-current/programs/_updown.netkey/_updown.netkey.in
--- openswan-2.6.32-cvs-patched/programs/_updown.netkey/_updown.netkey.in	2011-09-01 16:58:25.426675257 -0400
+++ openswan-2.6.32-current/programs/_updown.netkey/_updown.netkey.in	2011-09-02 15:05:35.184283030 -0400
@@ -179,6 +179,14 @@ downroute() {
     ip route flush cache
 }
 
+downrule() {
+        if [ -n "$PLUTO_MY_SOURCEIP" ]
+        then
+            doroute del
+            ip route flush cache
+        fi
+}
+
 updateresolvconf() {
 
 if [ -z "$PLUTO_NM_CONFIGURED" -o "$PLUTO_NM_CONFIGURED" = 0 ]; then
@@ -289,15 +297,13 @@ disconnectNM() {
 addsource() {
     st=0
     # check if given sourceip is local and add as alias if not
-    saddr=${PLUTO_MY_SOURCEIP%/*}/32
-    if test "${PLUTO_PEER_CLIENT##*/}" != 32
-    then
-	saddr=${PLUTO_MY_SOURCEIP%/*}/"${PLUTO_PEER_CLIENT##*/}"
-    fi
+    if ! ip -o route get ${PLUTO_MY_SOURCEIP%/*} | grep -q ^local; then
 
-    if ! ip addr show dev ${PLUTO_INTERFACE%:*} | grep -qs "inet ${saddr}"
-    then
-	it="ip addr add ${saddr} dev ${PLUTO_INTERFACE%:*}"
+	if [ -z "$PLUTO_IS_PEER_CISCO" -o "$PLUTO_IS_PEER_CISCO" = 0 ]; then
+	it="ip addr add ${PLUTO_MY_SOURCEIP%/*}/32 dev ${PLUTO_INTERFACE%:*}"
+	else
+	it="ip addr add ${PLUTO_MY_SOURCEIP%/*}/${PLUTO_PEER_CLIENT##*/} dev ${PLUTO_INTERFACE%:*}"
+	fi
 	oops="`eval $it 2>&1`"
 	st=$?
 	if [ " $oops" = " " -a " $st" != " 0" ]; then
@@ -320,17 +326,9 @@ addsource() {
 
 delsource() {
     st=0
-    # check if given sourceip is local and add as alias if not
+    # check if given sourceip is local 
     if  ip -o route get ${PLUTO_MY_SOURCEIP%/*} | grep -q ^local; then
-        #it="ip addr del ${PLUTO_MY_SOURCEIP%/*}/32 label ${PLUTO_INTERFACE%:*}:1 dev ${PLUTO_INTERFACE%:*}"
-
-                saddr=${PLUTO_MY_SOURCEIP%/*}/32
-                if test "${PLUTO_PEER_CLIENT##*/}" != 32
-                then
-                saddr=${PLUTO_MY_SOURCEIP%/*}/"${PLUTO_PEER_CLIENT##*/}"
-                fi
-
-        it="ip addr del ${saddr} dev ${PLUTO_INTERFACE%:*}"
+        it="ip addr del ${PLUTO_MY_SOURCEIP%/*}/${PLUTO_PEER_CLIENT##*/} dev ${PLUTO_INTERFACE%:*}"
 
         oops="`eval $it 2>&1`"
         st=$?
@@ -346,7 +344,7 @@ delsource() {
                 ;;
         esac
         if [ " $oops" != " " -o " $st" != " 0" ]; then
-            echo "$0: addsource \`$it' failed ($oops)" >&2
+            echo "$0: delsource \`$it' failed ($oops)" >&2
         fi
     fi
     return $st
@@ -391,9 +389,11 @@ doroute() {
 	parms2="$parms2 src ${PLUTO_MY_SOURCEIP%/*}"
     fi
 
+    if [ -z "$PLUTO_IS_PEER_CISCO" -o "$PLUTO_IS_PEER_CISCO" = 1 ]; then 
     if [ "$1" = "del" -a -n "$PLUTO_MY_SOURCEIP" ]; then
         delsource
     fi
+    fi
 
     case "$PLUTO_PEER_CLIENT" in
 	"0.0.0.0/0")
@@ -438,6 +438,7 @@ case "$PLUTO_VERB" in
 	;;
     down-host)
 	# connection to me going down
+	downrule
 	# If you are doing a custom version, firewall commands go here.
 	;;
     up-client)
@@ -446,6 +447,7 @@ case "$PLUTO_VERB" in
 	;;
     down-client)
 	# connection to my client subnet going down
+	downrule
 	# If you are doing a custom version, firewall commands go here.
 	;;
     updateresolvconf-host|updateresolvconf-client)
