diff -urNp openswan-2.6.32-patched/include/pluto_constants.h openswan-2.6.32-current/include/pluto_constants.h
--- openswan-2.6.32-patched/include/pluto_constants.h	2012-02-15 13:36:20.179547554 -0500
+++ openswan-2.6.32-current/include/pluto_constants.h	2012-03-01 15:50:42.015571370 -0500
@@ -301,6 +301,13 @@ enum phase1_role {
   RESPONDER=2
 };
 
+enum ikev2_msgtype {
+  req_sent=1,
+  req_recd=2,
+  response_sent=3,
+  response_recd=4
+};
+
 
 #define STATE_IKE_FLOOR	STATE_MAIN_R0
 
@@ -336,7 +343,7 @@ enum phase1_role {
 #define IS_MODE_CFG_ESTABLISHED(s) ((s) == STATE_MODE_CFG_R2)
 #endif
 
-#define IS_PARENT_SA_ESTABLISHED(s) ((s) == STATE_PARENT_I2 || (s) == STATE_PARENT_R1 || (s) == STATE_IKESA_DEL)
+#define IS_PARENT_SA_ESTABLISHED(s) ((s) == STATE_PARENT_I2 || (s) == STATE_PARENT_R1)
 #define IS_CHILD_SA_ESTABLISHED(st) (((st->st_state) == STATE_PARENT_I3 || (st->st_state) == STATE_PARENT_R2 || (st->st_state) == STATE_CHILDSA_DEL) && (st->st_childsa != NULL))
 
 
diff -urNp openswan-2.6.32-patched/programs/pluto/hmac.c openswan-2.6.32-current/programs/pluto/hmac.c
--- openswan-2.6.32-patched/programs/pluto/hmac.c	2012-02-15 13:36:18.633547484 -0500
+++ openswan-2.6.32-current/programs/pluto/hmac.c	2012-03-01 16:03:35.866518293 -0500
@@ -158,13 +158,9 @@ hmac_update(struct hmac_ctx *ctx,
     const u_char *data, size_t data_len)
 {
 #ifdef HAVE_LIBNSS
-    DBG(DBG_CRYPT, DBG_dump("hmac_update data value: ", data, data_len));
     if(data_len > 0) {
-	DBG(DBG_CRYPT, DBG_log("hmac_update: inside if"));
 	SECStatus status = PK11_DigestOp(ctx->ctx_nss, data, data_len);
-	DBG(DBG_CRYPT, DBG_log("hmac_update: after digest"));
 	PR_ASSERT(status == SECSuccess);
-	DBG(DBG_CRYPT, DBG_log("hmac_update: after assert"));
     }
 #else
     ctx->h->hash_update(&ctx->hash_ctx, data, data_len);
diff -urNp openswan-2.6.32-patched/programs/pluto/ikev2.c openswan-2.6.32-current/programs/pluto/ikev2.c
--- openswan-2.6.32-patched/programs/pluto/ikev2.c	2012-02-15 13:36:18.932547492 -0500
+++ openswan-2.6.32-current/programs/pluto/ikev2.c	2012-03-01 16:08:50.040489219 -0500
@@ -246,7 +246,6 @@ ikev2_process_payloads(struct msg_digest
 	int thisp = np;
 	bool unknown_payload = FALSE;
 
-	DBG(DBG_CONTROL, DBG_log("Now lets proceed with payload (%)",enum_show(&payload_names, thisp)));	
 	memset(pd, 0, sizeof(*pd));
 	
 	if (pd == &md->digest[PAYLIMIT])
@@ -314,7 +313,6 @@ ikev2_process_payloads(struct msg_digest
 	pd++;
     }
     
-    DBG(DBG_CONTROL, DBG_log("Finished and now at the end of ikev2_process_payload"));
     md->digest_roof = pd;
     return STF_OK;
 }
@@ -344,19 +342,13 @@ process_v2_packet(struct msg_digest **md
 
     md->msgid_received = ntohl(md->hdr.isa_msgid);
 
-	/* TODO: this code allows a packet to both set ISAKMP_FLAGS_I and ISAKMP_FLAGS_R */
-
-    //if( (md->hdr.isa_flags & ISAKMP_FLAGS_I) && (md->hdr.isa_flags & ISAKMP_FLAGS_R) ) {
-    //	openswan_log("received packet that claimed to be  both (I)nitiator and (R)esponder, msgid=%u", md->msgid_received);
-    //}
-
     if(md->hdr.isa_flags & ISAKMP_FLAGS_I) {
 	/* then I am the responder */
 	rcookiezero = is_zero_cookie(md->hdr.isa_rcookie);
 
 	md->role = RESPONDER;
 
-	DBG(DBG_CONTROL, DBG_log("I am IKE SA Responder"));
+	DBG(DBG_CONTROLMORE, DBG_log("I am IKE SA Responder"));
 
 	st = find_state_ikev2_parent(md->hdr.isa_icookie
 				     , md->hdr.isa_rcookie);
@@ -367,24 +359,35 @@ process_v2_packet(struct msg_digest **md
 	}
 
 	if(st) {
-	    if(st->st_msgid_lastrecv >  md->msgid_received){
+	    /* if it is request from Initiator*/
+	    if(!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {
+		if(st->st_msgid_last_remotereq != INVALID_MSGID && st->st_msgid_last_remotereq > md->msgid_received){
 		/* this is an OLD retransmit. we can't do anything */
-		openswan_log("received too old retransmit: %u < %u"
-			     , md->msgid_received, st->st_msgid_lastrecv);
+		openswan_log("received too old retransmit, ignoring: %u < %u"
+			     , md->msgid_received, st->st_msgid_last_remotereq);
 		return;
-	    }
-	    if(st->st_msgid_lastrecv == md->msgid_received){
+		}
+		if(st->st_msgid_last_remotereq != INVALID_MSGID && st->st_msgid_last_remotereq == md->msgid_received){
 		/* this is a recent retransmit. */
 		send_packet(st, "ikev2-responder-retransmit", FALSE);
 		return;
+		}
+	    }
+	    else 
+	    {
+	    /* if it is response from Initiator*/
+		/* it seems that it should not happen 
+		 * why a response will be retransmitted?
+		 */
+		if(st->st_msgid_last_localreq_ack!=INVALID_MSGID &&  st->st_msgid_last_localreq_ack >= md->msgid_received){
+		openswan_log("received an old response, ignoring: %u < %u"
+                             , md->msgid_received, st->st_msgid_last_localreq_ack);
+		}
 	    }
 	    /* update lastrecv later on */
 	}
-    //} else if(!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {
-	//openswan_log("received packet that was neither (I)nitiator or (R)esponder, msgid=%u", md->msgid_received);
-	
     } else {
-        /* then I am the initiator, and this is a reply */
+        /* then I am the initiator, and this may be a reply or request */
 	
 	md->role = INITIATOR;
 
@@ -421,26 +424,31 @@ process_v2_packet(struct msg_digest **md
 	}
 
 	if(st) {
-	    /*
-	     * then there is something wrong with the msgid, so
-	     * maybe they retransmitted for some reason. 
-	     * Check if it's an old packet being returned, and
-	     * if so, drop it.
-	     * NOTE: in_struct() changed the byte order.
-	     */
-	    if(st->st_msgid_lastack != INVALID_MSGID
-	       && md->msgid_received <= st->st_msgid_lastack) {
-		/* it's fine, it's just a retransmit */
-		DBG(DBG_CONTROL, DBG_log("responding peer retransmitted msgid %u"
-					 , md->msgid_received));
+	    /* if it is request from Responder*/
+	    if(!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {
+		if(st->st_msgid_last_remotereq != INVALID_MSGID && st->st_msgid_last_remotereq > md->msgid_received){
+		/* this is an OLD retransmit. we can't do anything */
+		openswan_log("received too old retransmit, ignoring: %u < %u"
+			     , md->msgid_received, st->st_msgid_last_remotereq);
+		return;
+		}
+		if(st->st_msgid_last_remotereq != INVALID_MSGID && st->st_msgid_last_remotereq == md->msgid_received){
+		/* this is a recent retransmit. */
+		send_packet(st, "ikev2-responder-retransmit", FALSE);
 		return;
+		}
+	    }
+	    else 
+	    {
+	    /* if it is response from Responder*/
+		/* it seems that it should not happen 
+		 * why a response will be retransmitted?
+		 */
+		if(st->st_msgid_last_localreq_ack!=INVALID_MSGID &&  st->st_msgid_last_localreq_ack >= md->msgid_received){
+		openswan_log("received an old response, ignoring: %u < %u"
+                             , md->msgid_received, st->st_msgid_last_localreq_ack);
+		}
 	    }
-#if 0
-	    openswan_log("last msgid ack is %u, received: %u"
-			 , st->st_msgid_lastack
-			 , md->msgid_received);
-	    return;
-#endif
 	}
     }
 	
@@ -448,7 +456,6 @@ process_v2_packet(struct msg_digest **md
     if(st) {
 
 	from_state = st->st_state;
-	DBG(DBG_CONTROL, DBG_log("state found and its state is (%s)", enum_show(&state_names, from_state)));
     }
 
     for(svm = state_microcode_table; svm->state != STATE_IKEv2_ROOF; svm++) {
@@ -460,20 +467,12 @@ process_v2_packet(struct msg_digest **md
 	}
 	if(svm->state != from_state) continue;
 	if(svm->recv_type != ix) continue;
-
-	/* I1 receiving NO_PROPOSAL ened up picking the wrong STATE_UNDEFINED state
- 	   Since the wrong state is a responder, we just add a check for initiator,
-	   so we hit STATE_IKEv2_ROOF
-	 */
-	//if ( ((svm->flags&SMF2_INITIATOR) != 0) != ((md->hdr.isa_flags & ISAKMP_FLAGS_R) != 0) )
-        //        continue;
 	
 	/* must be the right state */
 	break;
     }
 
     if(svm->state == STATE_IKEv2_ROOF) {
-	DBG(DBG_CONTROL, DBG_log("ended up with STATE_IKEv2_ROOF"));
 
 	/* no useful state */
 	if(md->hdr.isa_flags & ISAKMP_FLAGS_I) {
@@ -489,7 +488,6 @@ process_v2_packet(struct msg_digest **md
 	stf_status stf;
 	stf = ikev2_process_payloads(md, &md->message_pbs
 				     , from_state, md->hdr.isa_np);
-	DBG(DBG_CONTROL, DBG_log("Finished processing ikev2_process_payloads"));
 	
 	if(stf != STF_OK) {
 	    complete_v2_state_transition(mdp, stf);
@@ -497,7 +495,6 @@ process_v2_packet(struct msg_digest **md
 	}
     }
 
-    DBG(DBG_CONTROL, DBG_log("Now lets proceed with state specific processing"));
     DBG(DBG_PARSING,
 	if (pbs_left(&md->message_pbs) != 0)
 	    DBG_log("removing %d bytes of padding", (int) pbs_left(&md->message_pbs)));
@@ -676,7 +673,7 @@ send_v2_notification_from_md(struct msg_
 			 md->hdr.isa_icookie, md->hdr.isa_rcookie, data);
 }
 
-void ikev2_update_counters(struct msg_digest *md)
+void ikev2_update_counters(struct msg_digest *md, enum ikev2_msgtype msgtype)
 {
     struct state *pst= md->pst;
     struct state *st = md->st;
@@ -688,17 +685,21 @@ void ikev2_update_counters(struct msg_di
 	if(pst == NULL) pst = st;
     }
     
-    switch(md->role) {
-    case INITIATOR:
-	/* update lastuse values */
-	pst->st_msgid_lastack = md->msgid_received;
-	pst->st_msgid_nextuse = pst->st_msgid_lastack+1;
-	break;
-	
-    case RESPONDER:
-	pst->st_msgid_lastrecv= md->msgid_received;
-	break;
-    }
+
+	switch(msgtype) {
+	case req_sent:
+		pst->st_msgid_last_localreq = pst->st_msgid_last_localreq == INVALID_MSGID? 0 : pst->st_msgid_last_localreq + 1;
+		break;
+	case req_recd:
+		break;
+	case response_sent:
+		pst->st_msgid_last_remotereq = md->msgid_received;
+		break;
+	case response_recd:
+		pst->st_msgid_last_localreq_ack = md->msgid_received;
+		break;
+	default: break;
+	}
 }
 
 static void success_v2_state_transition(struct msg_digest **mdp)
@@ -716,8 +717,6 @@ static void success_v2_state_transition(
     change_state(st, svm->next_state);
     w = RC_NEW_STATE + st->st_state;    
 
-    ikev2_update_counters(md);
-
 
     /* tell whack and log of progress */
     {
diff -urNp openswan-2.6.32-patched/programs/pluto/ikev2.h openswan-2.6.32-current/programs/pluto/ikev2.h
--- openswan-2.6.32-patched/programs/pluto/ikev2.h	2012-02-15 13:36:18.652547484 -0500
+++ openswan-2.6.32-current/programs/pluto/ikev2.h	2012-02-16 17:20:27.664982024 -0500
@@ -145,7 +145,7 @@ extern stf_status ikev2_child_sa_respond
 					 , pb_stream *outpbs);
 
 extern struct traffic_selector ikev2_subnettots(struct end *e);
-extern void ikev2_update_counters(struct msg_digest *md);
+extern void ikev2_update_counters(struct msg_digest *md, enum ikev2_msgtype msgtype);
 
 extern void send_v2_notification(struct state *p1st, u_int16_t type
 				 , struct state *encst 
diff -urNp openswan-2.6.32-patched/programs/pluto/ikev2_parent.c openswan-2.6.32-current/programs/pluto/ikev2_parent.c
--- openswan-2.6.32-patched/programs/pluto/ikev2_parent.c	2012-02-15 13:36:18.644547484 -0500
+++ openswan-2.6.32-current/programs/pluto/ikev2_parent.c	2012-03-01 16:10:19.963480172 -0500
@@ -119,8 +119,9 @@ ikev2parent_outI1(int whack_sock
     initialize_new_state(st, c, policy, try, whack_sock, importance);
     st->st_ikev2 = TRUE;
     change_state(st, STATE_PARENT_I1);
-    st->st_msgid_lastack = INVALID_MSGID;
-    st->st_msgid_nextuse = 0;
+    st->st_msgid_last_localreq = INVALID_MSGID;
+    st->st_msgid_last_localreq_ack = INVALID_MSGID;
+    st->st_msgid_last_remotereq=INVALID_MSGID;	
     st->st_try   = try;
 
     if (HAS_IPSEC_POLICY(policy)) {
@@ -467,6 +468,7 @@ ikev2_parent_outI1_common(struct msg_dig
 
     /* Transmit */
     send_packet(st, __FUNCTION__, TRUE);
+    ikev2_update_counters(md, req_sent);
 
     /* Set up a retransmission event, half a minute henceforth */
     TCLCALLOUT("v2_adjustTimers", st, st->st_connection, md);
@@ -547,8 +549,9 @@ stf_status ikev2parent_inI1outR1(struct 
 	initialize_new_state(st, c, policy, 0, NULL_FD, pcim_stranger_crypto);
 	st->st_ikev2 = TRUE;
 	change_state(st, STATE_PARENT_R1);
-	st->st_msgid_lastack = INVALID_MSGID;
-	st->st_msgid_nextuse = 0;
+	st->st_msgid_last_localreq = INVALID_MSGID;
+	st->st_msgid_last_localreq_ack = INVALID_MSGID;
+	st->st_msgid_last_remotereq=INVALID_MSGID;
 
 	md->st = st;
 	md->from_state = STATE_IKEv2_BASE;
@@ -741,7 +744,7 @@ ikev2_parent_inI1outR1_tail(struct pluto
 
     /* start of SA out */
     {
-	struct isakmp_sa r_sa = sa_pd->payload.sa;
+	struct ikev2_sa r_sa = sa_pd->payload.v2sa;
 	notification_t rn;
 	pb_stream r_sa_pbs;
 
@@ -764,7 +767,6 @@ ikev2_parent_inI1outR1_tail(struct pluto
 	/* KE in */
 	rn=accept_KE(&st->st_gi, "Gi", st->st_oakley.group, keyex_pbs);
 	if(rn != NOTHING_WRONG) {
-	//char group_number[2];
 	u_int16_t group_number = htons(st->st_oakley.group->group);
 	dc.ptr = (char *)&group_number;
 	dc.len = 2;
@@ -772,7 +774,6 @@ ikev2_parent_inI1outR1_tail(struct pluto
 	delete_state(st);
 	return STF_FAIL + rn;
 	}
-	//RETURN_STF_FAILURE(accept_KE(&st->st_gi, "Gi", st->st_oakley.group, keyex_pbs));
     } 
 
     /* Ni in */
@@ -826,6 +827,8 @@ ikev2_parent_inI1outR1_tail(struct pluto
 
     /* note: retransimission is driven by initiator */
 
+   ikev2_update_counters(md, response_sent);
+
     return STF_OK;
     
 }
@@ -875,9 +878,9 @@ stf_status ikev2parent_inR1outI2(struct 
 		md->svm = ikev2_parent_firststate();
 
 		change_state(st, STATE_PARENT_I1);
-    	st->st_msgid_lastack = INVALID_MSGID;
-	md->msgid_received = INVALID_MSGID;  /* AAA hack  */
-    	st->st_msgid_nextuse = 0;
+		st->st_msgid_last_localreq = INVALID_MSGID;
+		st->st_msgid_last_localreq_ack = INVALID_MSGID;
+		st->st_msgid_last_remotereq=INVALID_MSGID;
 
 		return ikev2_parent_outI1_common(md, st);  
     }
@@ -930,8 +933,8 @@ stf_status ikev2parent_inR1outI2(struct 
 	    return STF_FAIL + rn;
     }
 
-    /* update state */
-    ikev2_update_counters(md);
+    /* update state counters */
+    ikev2_update_counters(md, response_recd);
 
     /* now. we need to go calculate the g^xy */
     {
@@ -1092,18 +1095,13 @@ static stf_status ikev2_encrypt_msg(stru
 	DBG(DBG_CRYPT,
 	    DBG_dump("data after encryption:", encstart, cipherlen));
     }
-    
+
     /* okay, authenticate from beginning of IV */
     {
 	struct hmac_ctx ctx;
-	DBG(DBG_PARSING, DBG_log("Inside authloc"));
-	DBG(DBG_CRYPT, DBG_dump("authkey value: ", authkey->ptr, authkey->len));
 	hmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);
-	DBG(DBG_PARSING, DBG_log("Inside authloc after init"));
 	hmac_update(&ctx, authstart, authloc-authstart);
-	DBG(DBG_PARSING, DBG_log("Inside authloc after update"));
 	hmac_final(authloc, &ctx);
-	DBG(DBG_PARSING, DBG_log("Inside authloc after final"));
 
 	DBG(DBG_PARSING,
 	    DBG_dump("data being hmac:", authstart, authloc-authstart);
@@ -1288,7 +1286,7 @@ ikev2_parent_inR1outI2_tail(struct pluto
 
     pst = st;
     st = duplicate_state(pst);
-    st->st_msgid = htonl(pst->st_msgid_nextuse);
+    st->st_msgid = htonl(pst->st_msgid_last_localreq == INVALID_MSGID? 0 : pst->st_msgid_last_localreq + 1);
     insert_state(st);
     md->st = st;
     md->pst= pst;
@@ -1482,6 +1480,7 @@ ikev2_parent_inR1outI2_tail(struct pluto
     delete_event(st);
     event_schedule(EVENT_v2_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);
 
+    ikev2_update_counters(md, req_sent);
     return STF_OK;
     
 }
@@ -1740,6 +1739,7 @@ ikev2_parent_inI2outR2_tail(struct pluto
 	    r_hdr.isa_np    = ISAKMP_NEXT_v2E;
 	    r_hdr.isa_xchg  = ISAKMP_v2_AUTH;
 	    r_hdr.isa_flags = ISAKMP_FLAGS_R;
+	    r_hdr.isa_msgid = htonl(md->msgid_received);
 	    memcpy(r_hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);
 	    memcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);
 	    if (!out_struct(&r_hdr, &isakmp_hdr_desc, &reply_stream, &md->rbody))
@@ -1887,6 +1887,7 @@ ikev2_parent_inI2outR2_tail(struct pluto
 
     /* note: retransimission is driven by initiator */
 
+    ikev2_update_counters(md, response_sent);
     return STF_OK;
     
 }
@@ -2090,6 +2091,7 @@ stf_status ikev2parent_inR2(struct msg_d
      * Delete previous retransmission event.
      */
     delete_event(st);
+    ikev2_update_counters(md, response_recd);
 
     return STF_OK;
     
@@ -2274,15 +2276,15 @@ stf_status process_informational_ikev2(s
     {
 	stf_status ret; 
 
-	if(md->hdr.isa_flags & ISAKMP_FLAGS_I) {
+	if(!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {
 	DBG(DBG_CONTROLMORE
-		, DBG_log("received informational exchange request from INITIATOR"));
-	ret = ikev2_decrypt_msg(md, RESPONDER);
+		, DBG_log("received informational exchange request from %s", md->role == 1? "RESPONDER": "INITIATOR"));
+	ret = ikev2_decrypt_msg(md, md->role);
 	}
 	else {
 	DBG(DBG_CONTROLMORE
-		, DBG_log("received informational exchange request from RESPONDER"));
-	ret = ikev2_decrypt_msg(md, INITIATOR);
+		, DBG_log("received informational exchange response from %s", md->role == 1?"RESPONDER": "INITIATOR"));
+	ret = ikev2_decrypt_msg(md, md->role);
 	}
 
 	if(ret != STF_OK) return ret;
@@ -2304,13 +2306,13 @@ stf_status process_informational_ikev2(s
 	int            ivsize;
 	unsigned char *encstart;
 
-	/* beginning of data going out */
-	authstart = reply_stream.cur;
-
 	/* make sure HDR is at start of a clean buffer */
 	zero(reply_buffer);
 	init_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer), "information exchange reply packet");
 
+	/* beginning of data going out */
+	authstart = reply_stream.cur;
+
 	/* HDR out */
 	{
 		struct isakmp_hdr r_hdr ;
@@ -2511,7 +2513,7 @@ stf_status process_informational_ikev2(s
 	close_output_pbs(&md->rbody);
 	close_output_pbs(&reply_stream);
 
-	ret = ikev2_encrypt_msg(md, RESPONDER,
+	ret = ikev2_encrypt_msg(md, md->role,
                                     authstart,
                                     iv, encstart, authloc,
                                     &e_pbs, &e_pbs_cipher);
@@ -2528,14 +2530,19 @@ stf_status process_informational_ikev2(s
 			, "reply packet for informational exchange");
 
 	send_packet(st, __FUNCTION__, TRUE);
+	ikev2_update_counters(md, response_sent);
 	}
 
 	/* Now carry out the actualy task, we can not carry the actual task since 
  	* we need to send informational responde using existig SAs
  	*/
 
+	if(md->hdr.isa_flags & ISAKMP_FLAGS_R){
+		ikev2_update_counters(md, response_recd);
+	}
+
 	{
-		if(md->chain[ISAKMP_NEXT_v2D] && st->st_state != STATE_IKESA_DEL) {
+		if(md->chain[ISAKMP_NEXT_v2D]) {
 
 		for(p = md->chain[ISAKMP_NEXT_v2D]; p!=NULL; p = p->next) {
 		v2del = &p->payload.v2delete;
@@ -2721,12 +2728,14 @@ void ikev2_delete_out(struct state *st)
 	md.st = st;
 	md.pst= pst;
 	/* beginning of data going out */
-	authstart = reply_stream.cur;
 
 	/* make sure HDR is at start of a clean buffer */
 	zero(reply_buffer);
 	init_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer), "information exchange request packet");
 
+	/* beginning of data going out */
+        authstart = reply_stream.cur;
+
 	/* HDR out */
 	{
 		struct isakmp_hdr r_hdr ;
@@ -2736,7 +2745,7 @@ void ikev2_delete_out(struct state *st)
 		memcpy(r_hdr.isa_icookie, pst->st_icookie, COOKIE_SIZE);
 		r_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;
 		r_hdr.isa_np = ISAKMP_NEXT_v2E;
-		r_hdr.isa_msgid = htonl(pst->st_msgid_nextuse);
+		r_hdr.isa_msgid = htonl(pst->st_msgid_last_localreq == INVALID_MSGID? 0 : pst->st_msgid_last_localreq + 1);
 
 		/*set initiator bit if we are initiator*/
 		if(pst->st_state == STATE_PARENT_I2 || pst->st_state == STATE_PARENT_I3) {
@@ -2759,6 +2768,7 @@ void ikev2_delete_out(struct state *st)
 
 
 	/* insert an Encryption payload header */
+	zero(&e);
 	e.isag_np = ISAKMP_NEXT_v2D;
 	e.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;
 
@@ -2784,10 +2794,6 @@ void ikev2_delete_out(struct state *st)
 				{
 				pb_stream del_pbs;
 				struct ikev2_delete v2del_tmp;
-				//u_int16_t i, j=0;
-				//bool bogus;
-				//u_char *spi;
-				//char spi_buf[1024];
 
 				zero(&v2del_tmp);
 				v2del_tmp.isad_np = ISAKMP_NEXT_NONE;
@@ -2853,7 +2859,7 @@ void ikev2_delete_out(struct state *st)
 	send_packet(pst, __FUNCTION__, TRUE);
 
 	/* update state */
-	ikev2_update_counters(&md);
+	ikev2_update_counters(&md, req_sent);
 
 	}
 	
diff -urNp openswan-2.6.32-patched/programs/pluto/state.c openswan-2.6.32-current/programs/pluto/state.c
--- openswan-2.6.32-patched/programs/pluto/state.c	2012-02-15 13:36:18.758547520 -0500
+++ openswan-2.6.32-current/programs/pluto/state.c	2012-03-01 16:01:40.027527974 -0500
@@ -358,7 +358,7 @@ delete_state(struct state *st)
     struct connection *const c = st->st_connection;
     struct state *old_cur_state = cur_state == st? NULL : cur_state;
 
-    if(st->st_ikev2 && st->st_state != STATE_PARENT_R1 && st->st_state != STATE_PARENT_R2)
+    if(st->st_ikev2)
     {
     /* child sa*/
     if(st->st_clonedfrom != 0) 
diff -urNp openswan-2.6.32-patched/programs/pluto/state.h openswan-2.6.32-current/programs/pluto/state.h
--- openswan-2.6.32-patched/programs/pluto/state.h	2012-02-15 13:36:18.760547505 -0500
+++ openswan-2.6.32-current/programs/pluto/state.h	2012-03-01 10:44:05.047351194 -0500
@@ -249,12 +249,13 @@ struct state
     struct msgid_list  *st_used_msgids;        /* used-up msgids */
 
     /* IKEv2 things */
-    /* message ID sequence for things we send (as initiator) */
-    msgid_t            st_msgid_lastack;       /* last one peer acknowledged */
-    msgid_t            st_msgid_nextuse;       /* next one to use */
+    /* message ID sequence for things we send (as request) */
+    msgid_t            st_msgid_last_localreq;       /* last one sent as request by us */
+    msgid_t            st_msgid_last_localreq_ack;       /* last one sent acked by peer */
 
-    /* message ID sequence for things we receive (as responder) */
-    msgid_t            st_msgid_lastrecv;      /* last one peer sent */
+
+    /* message ID sequence for things we receive (as response) */
+   msgid_t            st_msgid_last_remotereq;       /* last remote request sent by peer */
 
 
     /* symmetric stuff */
